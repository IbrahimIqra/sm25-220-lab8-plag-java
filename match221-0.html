<html>
<head>
<title>A8_Sec01_23301580_Arup-Dash.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec01_23301580_Arup-Dash.txt<p></p><pre>
ï»¿#Task03:
public class Making_Binary_tree {
    private int[] tree_nodes; 
    private int size;


    public Making_Binary_tree(int m) {
        tree_nodes = new int[m];
        size = m;
        
        for (int i = 0; i &lt; m; i++) {
            tree_nodes[i] = 0;
        }
        buildMinHeap();
    }




    private void buildMinHeap() {
        for (int i = size/2 - 1; i &gt;= 0; i--) {
            sinkDown(i);
        }
    }




    public int getMinLoad() {
        return tree_nodes[0];
    }




    public void assignTask(int taskTime) {
        tree_nodes[0] += taskTime;
        sinkDown(0);
    }




    private void sinkDown(int pos) {
<a name="2"></a><font color="#0000FF"><a href="match221-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_8.gif"/></a>

        int smallest = pos;
        int left = 2 * pos + 1;
        int right = 2 * pos + 2;


        if (left &lt; size &amp;&amp; tree_nodes[left] &lt; tree_nodes[smallest]) {
            smallest = left;
        }
        if (right &lt; size &amp;&amp; tree_nodes[right] &lt; tree_nodes[smallest]) {
            smallest = right;
        }


        if (smallest != pos) {
</font>            swap(pos, smallest);
            sinkDown(smallest);
        }
    }




    private void swap(int a, int b) {
        int temp = tree_nodes[a];
        tree_nodes[a] = tree_nodes[b];
        tree_nodes[b] = temp;
    }


  
    public int[] getTreeloads() {
        return tree_nodes;
    }


 
<a name="4"></a><font color="#FF00FF"><a href="match221-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

    public static void main(String[] args) {
        int[] tasks = {2, 4, 7, 1, 6}; 
        int m = 4; 
        Making_Binary_tree tree = new Making_Binary_tree(m);
</font>

        System.out.println("Initializing tree:");
        printTree(tree.getTreeloads());


  
        for (int t : tasks) {
            System.out.println("\nAssigning nodes that takes " + t + " hours");
            tree.assignTask(t);
            System.out.println("Current tree loads:");
            printTree(tree.getTreeloads());
        }


        System.out.println("\nFinal tree distribution:");
        printTree(tree.getTreeloads());
    }


    private static void printTree(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}






#Task04:
public class Largestelementfinder {
    private int[] elements;
    private int size;


    public Largestelementfinder(int[] elem) {
        elements = new int[elem.length];
       
        for (int i = 0; i &lt; elem.length; i++) {
            elements[i] = elem[i];
        }
<a name="0"></a><font color="#FF0000"><a href="match221-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

        size = elem.length;
        buildMaxHeap();
    }


    private void buildMaxHeap() {
        for (int i = size/2 - 1; i &gt;= 0; i--) {
            sinkdown(i);
        }
    }


    private void sinkdown(int pos) {
        int biggest = pos;
        int left = 2 * pos + 1;
        int right = 2 * pos + 2;


        if (left &lt; size &amp;&amp; elements[left] &gt; elements[biggest]) {
            biggest = left;
        }
        if (right &lt; size &amp;&amp; elements[right] &gt; elements[biggest]) {
            biggest = right;
        }


        if (biggest != pos) {
</font>            swap(pos, biggest);
            sinkdown(biggest);
        }
    }


    private void swap(int a, int b) {
        int temp = elements[a];
        elements[a] = elements[b];
        elements[b] = temp;
    }


    public int getMaximum() {
        if (size == 0) return -1;
        return elements[0];
    }


    public int removeMaximum() {
        if (size == 0) return -1;
        
<a name="3"></a><font color="#00FFFF"><a href="match221-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

        int max = elements[0];
        elements[0] = elements[size-1];
        size--;
        sinkdown(0);
        
        return max;
    }


    public static int[] topElementfinder(int[] elem, int k) {
</font><a name="1"></a><font color="#00FF00"><a href="match221-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

        Largestelementfinder scoreHeap = new Largestelementfinder(elem);
        int[] topElements = new int[k];
        
        for (int i = 0; i &lt; k; i++) {
            topElements[i] = scoreHeap.removeMaximum();
        }
        
        return topElements;
    }


    public static void main(String[] args) {
        int[] missionTimes = {4, 10, 2, 8, 6, 7}; 
        int k = 3; 
        int[] fastestTimes = topElementfinder(missionTimes, k);
        
        System.out.println("\nTop " + k + " largest elements are:");
</font>        for (int t : fastestTimes) {
            System.out.print(t + " ");
        }
        System.out.println();
    }
}</pre>
</body>
</html>
